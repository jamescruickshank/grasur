#!/usr/bin/python3

# a utility for automatically generating torus graph diagrams
# the input data should be in JSON format. Essentially each diagram
# is specified by a Z^2-gain graph together with an embedding of the 
# vertices in the unit square. See test.json for an example


import decimal
import csv
import json

class Diagram(object):
    """self.tikz_code cpntains the autogenerated tex code, add_seg adds a line segment"""

    def __init__(self):
        self.tikz_code="""\n%cursor\n"""
        return



    def project(self,x1,y1,x2,y2,bottom_left=(decimal.Decimal('0.0'),decimal.Decimal('0.0')),top_right=(decimal.Decimal('1.0'),decimal.Decimal('1.0'))):

        dx = top_right[0]-bottom_left[0]
        dy = top_right[1]-bottom_left[1]

# first translate the segment so that x1,y1 is in the fund domain
        if x1 > top_right[0]:
            return self.project(x1-dx,y1,x2-dx,y2,bottom_left=bottom_left,top_right=top_right)

        if x1 < bottom_left[0]:
            return self.project(x1+dx,y1,x2+dx,y2,bottom_left=bottom_left,top_right=top_right)

        if y1 > top_right[1]:
            return self.project(x1,y1-dy,x2,y2-dy,bottom_left=bottom_left,top_right=top_right)

        if y1 < bottom_left[1]:
            return self.project(x1,y1+dy,x2,y2+dy,bottom_left=bottom_left,top_right=top_right)

# now if x2,y2 is also in the fund domain then return the segement
        if bottom_left[0]<=x2 and bottom_left[1]<=y2 and x2<=top_right[0] and y2<=top_right[1]:
            return [((x1,y1),(x2,y2))]

# recursion step
        if y2>top_right[1]:
            x3,y3 = x1+(x2-x1)*(top_right[1]-y1)/(y2-y1),top_right[1]
            return self.project(x1,y1,x3,y3,bottom_left=bottom_left,top_right=top_right)+self.project(x3,y3-dy,x2,y2-dy,bottom_left=bottom_left,top_right=top_right)

        if y2<bottom_left[1]:
            x3,y3 = x1+(x2-x1)*(bottom_left[1]-y1)/(y2-y1),bottom_left[1]
            return self.project(x1,y1,x3,y3,bottom_left=bottom_left,top_right=top_right)+self.project(x3,y3+dy,x2,y2+dy,bottom_left=bottom_left,top_right=top_right)

        if x2<bottom_left[0]:
            x3,y3 = bottom_left[0],y1+(y2-y1)*(bottom_left[0]-x1)/(x2-x1)
            return self.project(x1,y1,x3,y3,bottom_left=bottom_left,top_right=top_right)+self.project(x3+dx,y3,x2+dx,y2,bottom_left=bottom_left,top_right=top_right)

        if x2>top_right[0]:
            x3,y3 = top_right[0],y1+(y2-y1)*(top_right[0]-x1)/(x2-x1)
            return self.project(x1,y1,x3,y3,bottom_left=bottom_left,top_right=top_right)+self.project(x3-dx,y3,x2-dx,y2,bottom_left=bottom_left,top_right=top_right)


    def insert(self,code):
        n = self.tikz_code.index('\n%cursor')
        self.tikz_code = self.tikz_code[:n]+code+self.tikz_code[n:]
        return 

    def add_seg(self,start,end,line_width="1pt",**kwargs):
        a = (decimal.Decimal(str(start[0])),decimal.Decimal(str(start[1])))
        b = (decimal.Decimal(str(end[0])),decimal.Decimal(str(end[1])))
        line_template = "\\draw [line width={lw}] ({a0},{a1})--({b0},{b1});\n"
        seg_list = self.project(a[0],a[1],b[0],b[1])
        out_strings = [line_template.format(a0=i[0][0],a1=i[0][1],b0=i[1][0],b1=i[1][1],lw=line_width) for i in seg_list]
        self.insert("".join(out_strings))
        return

    def add_node(self,coords,line_width='1pt',radius='3pt',node_label="<++>",**kwargs):
        a = (decimal.Decimal(str(coords[0])),decimal.Decimal(str(coords[1])))
        out = "\\draw [fill=black,line width={lw}] ({x},{y}) circle ({ra});\n%node_label%\\draw ({x},{y}) node {{{node_label}}};\n".format(
                lw=line_width,
                x=str(a[0]),
                y=str(a[1]),
                ra=radius,
                node_label=node_label
            )
        if (a[0]==decimal.Decimal(0) or a[0] == decimal.Decimal(1)):
            out += "\\draw [fill=black,line width={lw}] ({x},{y}) circle ({ra});\n%node_label%\\draw ({x},{y}) node {{{node_label}}};\n".format(
                    lw=line_width,
                    x=str(1-a[0]),
                    y=str(a[1]),
                    ra=radius,
                    node_label=node_label
                )
        if (a[1]==decimal.Decimal(0) or a[1] == decimal.Decimal(1)):
            out += "\\draw [fill=black,line width={lw}] ({x},{y}) circle ({ra});\n%node_label%\\draw ({x},{y}) node {{{node_label}}};\n".format(
                    lw=line_width,
                    x=str(a[0]),
                    y=str(1-a[1]),
                    ra=radius,
                    node_label=node_label
                )
        if (a[0]==decimal.Decimal(0) or a[0] == decimal.Decimal(1)) and (a[1]==decimal.Decimal(0) or a[1] == decimal.Decimal(1)):
            out += "\\draw [fill=black,line width={lw}] ({x},{y}) circle ({ra});\n%node_label%\\draw ({x},{y}) node {{{node_label}}};\n".format(
                    lw=line_width,
                    x=str(1-a[0]),
                    y=str(1-a[1]),
                    ra=radius,
                    node_label=node_label
                )
 

        self.insert(out)
        return



class TorusGraph(object):
    """
    Model of a Gain graph embedded on a torus with straight line edges.
    """
    def __init__(self,**kwargs):
        self.nodes=[]
        self.edges=[]
        for key in kwargs:
            setattr(self,key,kwargs[key])

        return

    def tikz(self,**kwargs):
        diag = Diagram()
        for node in self.nodes:
            diag.add_node(node,**kwargs)
        for edge in self.edges:
            start = self.nodes[edge[0]]
            end = self.nodes[edge[1]]
            end = (end[0]+edge[2][0],end[1]+edge[2][1])
            diag.add_seg(start,end,**kwargs)
        return diag.tikz_code




def json2latex(input_file,cols=4,scale='2.0cm',label_pos='(0.5,-0.1)',fvectors=False,verbose=False,**kwargs):
    template="""\\begin{{tikzpicture}}[x={scale},y={scale}]
\\draw[dash pattern=on 2pt off 2pt] (0,0) rectangle (1,1);
{tikz}
{label}
\\end{{tikzpicture}}
{delimiter}"""
    output="\\begin{{tabular}}{{{a}}}\n".format(a="c"*cols)
    fin=open(input_file,'r')
    graphs = json.load(fin)
    counter = 0
    for graph in graphs:
        label = graph['label']
        if verbose:
            print('processing graph {label}'.format(label=label))
        if fvectors:
            label+=", "+graph['f_vector']
        nodes=tuple(graph['nodes'])
        edges=tuple(graph['edges'])
        tg = TorusGraph(nodes=nodes,edges=edges)
        label_tikz="\\draw {label_pos} node {{${label}$}};\n".format(
                label=label,
                label_pos=label_pos
                )
        counter+=1
        delimiter="%%%\n&\n%%%\n"
        if counter%cols==0:
            delimiter="%%%\n\\\\\n%%%\n"
        output+=template.format(
                scale=scale,
                tikz=tg.tikz(**kwargs),
                label=label_tikz,
                delimiter=delimiter,
            )
    output+="\\end{tabular}"
    output_file=input_file[:input_file.rfind(".")]+".tex"
    f =open(output_file,'w')
    f.write(output)
    f.close()
    if verbose:
        print("{n} lines written to {fn}".format(n=output.count('\n')+1,fn=output_file))
    return


import argparse

parser = argparse.ArgumentParser(description="Autogenerate LaTeX code for torus graph diagrams.")
parser.add_argument('in_file', type=str, help='path to a json file containing the torus graph data')
parser.add_argument('--cols','-c', type=int, help='number of columns in array',default=5)
parser.add_argument('--scale','-s', type=str, help='string specifying unit x (and y) length',default='2.0cm')
parser.add_argument('--label_pos','-p', type=str, help='string specifying positions of labels',default='(0.5,-0.15)')
parser.add_argument('--fvectors','-f', help='include f-vectors in labels',action="store_true")
parser.add_argument('--line_width','-l', type=str, help='string specifying line widths of edges',default='1.5pt')
parser.add_argument('--radius','-r', type=str, help='string specifying radius of nodes',default='3pt')

args = parser.parse_args()

json2latex(
        args.in_file,
        verbose=True,
        cols=args.cols,
        scale=args.scale,
        label_pos=args.label_pos,
        fvectors=args.fvectors,
        line_width=args.line_width,
        radius=args.radius
        )

